https://dsp.stackexchange.com/questions/56321/gnu-radio-transceiver-loopback-adapted-transmission-stops-unexpectedly



https://www.gnuradio.org/doc/doxygen/page_packet_comms.html
Um transmtter de physical layer define-se com as seguintes propriedades:
	-Data integrity check - Normalmente o CRC32 do payload e juntado ao final do frame.

	-Forward Error Correction (FEC) - Correção de bit durante a rececão. -https://www.gnuradio.org/doc/doxygen/page_fec.html

	-Frame formatting: Esperamos os dados a serem recebido do tranmsissor por alguma camada acima (MAC/Rede), que é o que nos tratamos como o payload. A camada fisica de seguida, coloca o seu proprio framming de modo a transmitir corretamente a outros radios e estes receberem corretamente, isto envolve alguma info do formato do payload (como tamanho, tipo de FEC usado, tipo de modulacao e parametros da modulacao). ------>>>>>A frame fisica adiciona uma word conhecida para ajudar na identificação e sincronzação.<<<<-------
	A utilizacao do Packet Header Formatter block para isto. https://www.gnuradio.org/doc/doxygen/classgr_1_1digital_1_1header__format__base.html

	-O Protoccol formatter(aync) tem 2 outputs: "Header" que emite o header criado para o payload baseado no formatter object. e o "Payload" que é o input re-emitted.  PErmitindo assim 2 caminhos para modulação diferenciada e codificação FEC diferenciada. (FEC mais robusto no header para garantir receção, e menos no payload para maximizar throughput) 

	NOTA IMP: Se aplicarmos adicionarmos Access code no Header e aplicarmos o FEC ao header, então o AC é encoded tambem, temos que garantir que o reciver está à procura do AC corretamente. (NO packet_tx ao usar o repetition emcoder, o AC tem 3 bit por cada 1 que tinha, e o packet_rx tem que ter em conta isto no COrretaltion estimator  nessa word)

	-Modular, podemos criar um modulador tanto para o header como para o payload. 

	-Depois podemos juntar numa unica stream para o envio da mesma. (Com o bloco Tagged Stream Mux block)

	-Burst Shapping and Filtering: shapes the packet for burst transmission, 2 blocos para que isto aconteca corretamente.
	Manipula a estrutura do burst aplicando diferentes formas de padding. Primeiro existe uma janela que é aplicada ao dominio do tempo do burst. Isto involve ramping up stage de 0 e ramping down stage para 0. A window é definida como vetor e a fft.window define funcoes como seé Hann ou Kaiser. O tamanho da janela é dividido a meio, a parte da esquerda para ramp-up e a parte da direita para ramp-down. 
	A janela tem 2 modos: Inserir/Não inserir phasing symbols. 
		Quando se insere, uma sequencia de 1's e -1's são inseridos drante periodos ramp-up e ramp-down, assim uma janela com 20 de tamanho, irá produzir 10 1's e -1's alternativos á frente do burst e outros 10 simbolos alternativos atraz do burst. A window é aplicada aos simbolos de phase e não afeta os burst symbols diretamente.
		Quando não usamos os phasing symbols, a janela é aplicada á frente e a traz do burst diretamente.
	O Burst shapper pode, tambem adicionar 0's á frente e atraz do burst, permitindo mais controlo da estrutura do burst. em particular aidiconar post-padding 0's que é o comprimento do delay do pulse shapping filter que vem a seguir, isto garante que o burst completo das samples é empurrado para o filtro e transmitido completamente.
	                  ____________________
                     /                    \
                    /                      \
                   /                        \
            ______/                          \____
            |  E  | D |        C         | B | A |

  A: Pre-padding 0's
  B: Ramp-up window
  C: Frame
  D: Ramp-down window
  E: Post-padding 0's


  Quando usamos hasing symbols: C é a frame inteira e B e D são cheios de 1's e -1's.
  Quando não usamos phase symbols a frame extende B atravez de C até D.

  Após isto colocamos o burst em pulse shapping filter. Este filtro modela complex samples em symbolos apropriados para transmissa baseado numa mascara espectral bem como up-samples do burst para o numero especificado de samples per second.   -->Polyphase Arbitrary Resampler, podemos assim especficar um valor de numero de SPS >=2. Um filtro tipico é o RRC (Root Raised Cosine) (TBM dá Gaussioan Filters).
  Como este filtro up-sample, usamos o Tagged Stream Multiply Length Tag block. O resamples não sabe de nada sobre tagged streams, por isso quando up-samples, o "tag value" dp TSB(tagged stream block) não altera, por isso temos que ser nos a alterar-lo. Isto ajuda principalmente quando estamos a usar UHD's e explicitmaente dizemos ao UHD Sink para experar uma tagged stream para gerir a transmissão em burst.


  